import requests
import sqlite3
import datetime
import time
import logging
from typing import Optional, Tuple, List, Dict
import os

# Configuration
API_KEY = os.getenv("API_FOOTBALL_KEY", "YOUR_API_FOOTBALL_KEY")
X_BEARER = os.getenv("X_BEARER_TOKEN", "YOUR_X_BEARER_TOKEN")
LEAGUE_IDS = [39, 2]  # Premier League, Champions League
DB_PATH = "fixtures.db"
CHECK_INTERVAL = 300  # 5 minutes in seconds

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('xg_poster.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class Database:
    """Handle SQLite operations for tracking posted fixtures"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.init_db()
    
    def init_db(self):
        """Create database table if it doesn't exist"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS fixtures_posted (
                fixture_id INTEGER PRIMARY KEY,
                league_id INTEGER,
                date TEXT,
                home_team TEXT,
                away_team TEXT,
                status TEXT,
                posted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
        conn.close()
        logger.info("Database initialized")
    
    def is_posted(self, fixture_id: int) -> bool:
        """Check if fixture has already been posted"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT 1 FROM fixtures_posted WHERE fixture_id = ?", (fixture_id,))
        result = cursor.fetchone() is not None
        conn.close()
        return result
    
    def mark_posted(self, fixture_id: int, league_id: int, date: str, 
                    home_team: str, away_team: str, status: str):
        """Mark fixture as posted"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT OR IGNORE INTO fixtures_posted 
            (fixture_id, league_id, date, home_team, away_team, status)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (fixture_id, league_id, date, home_team, away_team, status))
        conn.commit()
        conn.close()
        logger.info(f"Marked fixture {fixture_id} as posted")


class APIFootball:
    """Handle API-Football API calls"""
    
    BASE_URL = "https://v3.football.api-sports.io"
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.headers = {"x-apisports-key": api_key}
    
    def get_fixtures(self, league_id: int, date: str) -> List[Dict]:
        """Get all fixtures for a specific league and date"""
        url = f"{self.BASE_URL}/fixtures"
        params = {"league": league_id, "date": date}
        
        try:
            response = requests.get(url, headers=self.headers, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            return data.get("response", [])
        except requests.exceptions.RequestException as e:
            logger.error(f"Error fetching fixtures for league {league_id}: {e}")
            return []
    
    def get_xg(self, fixture_id: int) -> Tuple[Optional[float], Optional[float]]:
        """Get xG values for both teams"""
        url = f"{self.BASE_URL}/fixtures/statistics"
        params = {"fixture": fixture_id}
        
        try:
            response = requests.get(url, headers=self.headers, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            stats = data.get("response", [])
            
            if len(stats) < 2:
                logger.warning(f"Insufficient statistics data for fixture {fixture_id}")
                return None, None
            
            def find_xg(stat_list: List[Dict]) -> Optional[float]:
                """Extract xG value from statistics list"""
                for stat in stat_list:
                    if stat.get("type", "").lower() in ["expected goals", "expected_goals"]:
                        value = stat.get("value")
                        if value is not None:
                            try:
                                return float(value)
                            except (ValueError, TypeError):
                                continue
                return None
            
            home_xg = find_xg(stats[0].get("statistics", []))
            away_xg = find_xg(stats[1].get("statistics", []))
            
            return home_xg, away_xg
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Error fetching xG for fixture {fixture_id}: {e}")
            return None, None


class XPoster:
    """Handle posting to X/Twitter"""
    
    API_URL = "https://api.x.com/2/tweets"
    
    def __init__(self, bearer_token: str):
        self.bearer_token = bearer_token
        self.headers = {
            "Authorization": f"Bearer {bearer_token}",
            "Content-Type": "application/json"
        }
    
    def post_tweet(self, text: str) -> bool:
        """Post a tweet and return success status"""
        try:
            response = requests.post(
                self.API_URL,
                json={"text": text},
                headers=self.headers,
                timeout=10
            )
            response.raise_for_status()
            logger.info(f"Successfully posted tweet: {text}")
            return True
        except requests.exceptions.RequestException as e:
            logger.error(f"Error posting tweet: {e}")
            return False


class XGScorePoster:
    """Main orchestrator for the xG score posting system"""
    
    def __init__(self):
        self.db = Database(DB_PATH)
        self.api = APIFootball(API_KEY)
        self.poster = XPoster(X_BEARER)
    
    def format_tweet(self, home_team: str, away_team: str, 
                     home_score: int, away_score: int,
                     home_xg: float, away_xg: float) -> str:
        """Format the tweet text"""
        # Shorten team names if needed
        home_team = self.shorten_team_name(home_team)
        away_team = self.shorten_team_name(away_team)
        
        # Format xG with 2 decimal places, removing trailing zeros
        home_xg_str = f"{home_xg:.2f}".rstrip('0').rstrip('.')
        away_xg_str = f"{away_xg:.2f}".rstrip('0').rstrip('.')
        
        return f"{home_team} ({home_xg_str}) {home_score}â€“{away_score} ({away_xg_str}) {away_team}"
    
    def shorten_team_name(self, name: str) -> str:
        """Shorten common team names for tweet brevity"""
        replacements = {
            "Manchester City": "Man City",
            "Manchester United": "Man United",
            "Tottenham Hotspur": "Tottenham",
            "Brighton & Hove Albion": "Brighton",
            "West Ham United": "West Ham",
            "Newcastle United": "Newcastle",
            "Nottingham Forest": "Nott'm Forest",
            "Wolverhampton Wanderers": "Wolves"
        }
        return replacements.get(name, name)
    
    def process_fixture(self, fixture: Dict) -> bool:
        """Process a single fixture and post if appropriate"""
        fixture_id = fixture["fixture"]["id"]
        status = fixture["fixture"]["status"]["short"]
        
        # Only process finished matches
        if status != "FT":
            return False
        
        # Check if already posted
        if self.db.is_posted(fixture_id):
            logger.debug(f"Fixture {fixture_id} already posted, skipping")
            return False
        
        # Extract match data
        home_team = fixture["teams"]["home"]["name"]
        away_team = fixture["teams"]["away"]["name"]
        home_score = fixture["goals"]["home"]
        away_score = fixture["goals"]["away"]
        league_id = fixture["league"]["id"]
        date = fixture["fixture"]["date"][:10]
        
        # Get xG values
        home_xg, away_xg = self.api.get_xg(fixture_id)
        
        if home_xg is None or away_xg is None:
            logger.warning(f"Missing xG data for fixture {fixture_id} ({home_team} vs {away_team})")
            # Still mark as posted to avoid repeated attempts
            self.db.mark_posted(fixture_id, league_id, date, home_team, away_team, status)
            return False
        
        # Format and post tweet
        tweet_text = self.format_tweet(home_team, away_team, home_score, away_score, home_xg, away_xg)
        
        if self.poster.post_tweet(tweet_text):
            self.db.mark_posted(fixture_id, league_id, date, home_team, away_team, status)
            return True
        
        return False
    
    def run_once(self):
        """Run one check cycle for all leagues"""
        today = datetime.date.today().strftime("%Y-%m-%d")
        logger.info(f"Checking fixtures for {today}")
        
        posted_count = 0
        
        for league_id in LEAGUE_IDS:
            fixtures = self.api.get_fixtures(league_id, today)
            logger.info(f"Found {len(fixtures)} fixtures for league {league_id}")
            
            for fixture in fixtures:
                if self.process_fixture(fixture):
                    posted_count += 1
                    time.sleep(2)  # Rate limiting between posts
        
        logger.info(f"Cycle complete. Posted {posted_count} new results")
    
    def run_continuous(self):
        """Run continuously with scheduled checks"""
        logger.info("Starting xG Score Poster (continuous mode)")
        logger.info(f"Checking every {CHECK_INTERVAL} seconds")
        
        while True:
            try:
                self.run_once()
            except Exception as e:
                logger.error(f"Error in main loop: {e}", exc_info=True)
            
            logger.info(f"Sleeping for {CHECK_INTERVAL} seconds...")
            time.sleep(CHECK_INTERVAL)


def main():
    """Entry point"""
    # Validate configuration
    if API_KEY == "YOUR_API_FOOTBALL_KEY" or X_BEARER == "YOUR_X_BEARER_TOKEN":
        logger.error("Please set API_FOOTBALL_KEY and X_BEARER_TOKEN environment variables")
        return
    
    poster = XGScorePoster()
    
    # Check command line args for mode
    import sys
    if len(sys.argv) > 1 and sys.argv[1] == "--once":
        logger.info("Running in single-check mode")
        poster.run_once()
    else:
        poster.run_continuous()


if __name__ == "__main__":
    main()